const dynamodb = require('aws-sdk/clients/dynamodb')
//const AWS = require('aws-sdk')
//AWS.config.update({ region: 'us-west-2' })
//AWS.config.credentials = new AWS.SharedIniFileCredentials({ profile: 'mfa' })

const types = {
  string: 'S',
  number: 'N'
}

const dynamodbObjects = {}

const getDynamodbObject = config => {
  if (!dynamodbObjects[config.storeName]) {
    dynamodbObjects[config.storeName] = new dynamodb({
      apiVersion: '2012-11-05',
      ...config.config
    })
  }
  return dynamodbObjects[config.storeName]
}

const createTable = ({ entry, config }) => {
  const dbClient = getDynamodbObject(config)
  const {
    name,
    readCapacityUnits,
    writeCapacityUnits,
    properties,
    indexes
  } = entry
  // This is the amount of read and write activity that the table will be able to support
  const provisionedThroughput = {
    ReadCapacityUnits: readCapacityUnits,
    WriteCapacityUnits: writeCapacityUnits
  }
  const keySchemas = []
  const attributeDefinitions = []
  properties.forEach(property => {
    const { name, type, key } = property
    const keyType = key === 'partition' ? 'HASH' : 'RANGE'
    const attributeType = types[type]
    const keySchema = {
      AttributeName: name,
      KeyType: keyType
    }
    const attributeDefinition = {
      AttributeName: name,
      AttributeType: attributeType
    }
    keySchemas.push(keySchema)
    attributeDefinitions.push(attributeDefinition)
  })
  const globalSecondaryIndexes = []
  indexes.forEach(index => {
    const { name, type, key } = index
    const attributeType = types[type]
    const keyType = key === 'partition' ? 'HASH' : 'RANGE'
    const globalIndex = {
      IndexName: `${name}-index`,
      Projection: {
        ProjectionType: 'ALL'
      },
      ProvisionedThroughput: {
        WriteCapacityUnits: writeCapacityUnits,
        ReadCapacityUnits: readCapacityUnits
      },
      KeySchema: [
        {
          KeyType: keyType,
          AttributeName: name
        }
      ]
    }
    const attributeDefinition = {
      AttributeName: name,
      AttributeType: attributeType
    }
    globalSecondaryIndexes.push(globalIndex)
    attributeDefinitions.push(attributeDefinition)
  })
  const params = {
    TableName: name,
    KeySchema: keySchemas,
    AttributeDefinitions: attributeDefinitions,
    ProvisionedThroughput: provisionedThroughput
  }
  if (globalSecondaryIndexes.length) {
    params.GlobalSecondaryIndexes = globalSecondaryIndexes
  }
  console.log('creating tables...')
  return new Promise((resolve, reject) => {
    dbClient.createTable(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const deleteTable = ({ entry, config }) => {
  const dbClient = getDynamodbObject(config)
  const { name } = entry
  const params = {
    TableName: name
  }
  console.log('deleting tables...')
  return new Promise((resolve, reject) => {
    dbClient.deleteTable(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const add = ({ objectName, objectData, config }) => {
  const dbClient = getDynamodbObject(config)
  const toExpression = objectData => {
    const item = {}
    Object.keys(objectData).forEach(name => {
      item[name] = {
        S: objectData[name]
      }
    })
    return item
  }
  const params = {
    TableName: objectName,
    Item: toExpression(objectData)
  }
  return new Promise((resolve, reject) => {
    dbClient.putItem(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const get = ({ id, idName, objectName, config, filters }) => {
  const dbClient = getDynamodbObject(config)
  const params = {
    // TODO: make these config options
    TableName: objectName,
    ScanIndexForward: false,
    KeyConditionExpression: `${idName} = :id`,
    ExpressionAttributeValues: {
      ':id': {
        S: id
      }
    }
  }
  if (filters.sortKeySearch && filters.sortKeyFunction) {
    params.KeyConditionExpression += ` AND ${filters.sortKeyFunction}(${config.rangeKey}, :sk)`
    params.ExpressionAttributeValues[':sk'] = {
      S: filters.sortKeySearch
    }
  }
  return new Promise((resolve, reject) => {
    dbClient.query(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const setUpdateExpression = (objectData, idName, config) => {
  const expressions = []
  const expressionAttributeValues = {}
  Object.keys(objectData).forEach(property => {
    if (config.rangeKey && property === config.rangeKey) {
      return
    }
    if (property === idName) {
      return
    }
    const attribute = `:${property}`
    const expression = `${property} = ${attribute}`
    expressions.push(expression)
    expressionAttributeValues[attribute] = {
      S: objectData[property]
    }
  })
  const updateExpression = 'SET ' + expressions.join(', ')
  return {
    UpdateExpression: updateExpression,
    ExpressionAttributeValues: expressionAttributeValues
  }
}

const update = ({ objectName, idName, id, objectData, config }) => {
  const objectKey = {
    [idName]: {
      S: id
    }
  }
  if (config.rangeKey) {
    objectKey[config.rangeKey] = {
      S: objectData[config.rangeKey]
    }
  }
  const dbClient = getDynamodbObject(config)
  const { UpdateExpression, ExpressionAttributeValues } = setUpdateExpression(
    objectData,
    idName,
    config
  )
  const params = {
    TableName: objectName,
    Key: objectKey,
    UpdateExpression,
    ExpressionAttributeValues,
    ReturnValues: (config.update && config.update.returnValues) || 'NONE'
  }

  return new Promise((resolve, reject) => {
    dbClient.updateItem(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const del = ({ objectName, idName, id, objectData, config }) => {
  const dbClient = getDynamodbObject(config)
  const params = {
    TableName: objectName,
    Key: {
      [idName]: {
        S: id
      }
    }
  }
  if (config.rangeKey) {
    params.Key[config.rangeKey] = {
      S: objectData[config.rangeKey]
    }
  }

  return new Promise((resolve, reject) => {
    dbClient.deleteItem(params, (err, data) => {
      if (err) {
        reject(err)
      }
      resolve(data)
    })
  })
}

const applyStepEntry = async ({ entry, config }) => {
  return actions[entry.action]({ entry, config })
}

const logStepComplete = async stepIndex => {
  console.log(`log step complete ${stepIndex}`)
  return
}

const currentStep = async () => {
  console.log('in current step')
  return -1
}

const handleStepError = async err => {
  console.log(err)
  return
}

const close = async () => {}

const init = () => {}

const actions = {
  createObject: ({ entry, config }) => {
    createTable({ entry, config })
  },
  deleteObject: ({ entry, config }) => {
    deleteTable({ entry, config })
  }
}

module.exports = {
  init,
  applyStepEntry,
  currentStep,
  handleStepError,
  logStepComplete,
  close,
  add,
  update,
  get,
  delete: del
}
