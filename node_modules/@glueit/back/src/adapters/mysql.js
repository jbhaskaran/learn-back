const mysql = require('mysql')

let connection = null

const getColumnType = (name, d, action = 'createObject') => {
  const typesPrimary = {
    number: d.value || 'INT AUTO_INCREMENT',
    byte: d.value || `BINARY(${d.length})`
  }

  const typesForeign = {
    number: d.value || 'INT',
    byte: d.value || `BINARY(${d.length})`
  }

  if (name === 'id') {
    if (action === 'createObject') {
      return `${typesPrimary[d.type] ||
        'INT AUTO_INCREMENT'}, PRIMARY KEY (${d.keyName || name})`
    }
    return `${typesPrimary[d.type] || 'INT AUTO_INCREMENT'}`
  } else if (/Id$/.test(name)) {
    return `${typesForeign[d.type] || 'INT'}`
  }

  const types = {
    string: d.value || `VARCHAR(${d.length})`,
    number: d.value || 'DECIMAL(9, 2)',
    boolean: 'BOOLEAN',
    object: 'JSON',
    binary: d.value || `BINARY(${d.length})`
  }
  return types[d.type] || d.type
}

const getColumnDefault = d => {
  if (d.default) {
    return `DEFAULT ${d.default}`
  }
  return ''
}

const getFields = properties => {
  const strs = []
  properties.forEach(entry => {
    strs.push(
      `${entry.name} ${getColumnType(entry.name, entry)} ${getColumnDefault(
        entry
      )}`
    )
  })
  return strs.join(',\n')
}

const runQuery = str => {
  return new Promise((resolve, reject) => {
    console.log(str)
    connection.query(str, (err, result) => {
      if (err) {
        reject(err)
      }
      resolve(result)
    })
  })
}

const actions = {
  dropSpace: ({ entry }) => {
    return runQuery(`DROP DATABASE IF EXISTS ${entry.name}`)
  },
  createSpace: ({ entry }) => {
    return runQuery(`CREATE DATABASE IF NOT EXISTS ${entry.name}`)
  },
  useSpace: ({ entry }) => {
    return runQuery(`USE ${entry.name}`)
  },
  createObject: ({ entry }) => {
    return runQuery(
      `CREATE TABLE IF NOT EXISTS ${entry.name} (${getFields(
        entry.properties
      )})`
    )
  },
  removeObject: ({ entry }) => {
    return runQuery(`DROP TABLE IF EXISTS ${entry.name}`)
  },
  createProperty: ({ entry }) => {
    return runQuery(
      `ALTER TABLE ${entry.on} ADD COLUMN ${entry.name} ${getColumnType(
        entry.name,
        entry,
        'createProperty'
      )} ${getColumnDefault(entry)}`
    )
  },
  updateProperty: ({ entry }) => {
    return runQuery(
      `ALTER TABLE ${entry.on} CHANGE COLUMN ${entry.name} ${entry.newName ||
        entry.name} ${getColumnType(
        entry.name,
        entry,
        'updateProperty'
      )} ${getColumnDefault(entry)}`
    )
  },
  removeProperty: ({ entry }) => {
    return runQuery(`ALTER TABLE ${entry.on} DROP COLUMN ${entry.name}`)
  },
  query: ({ entry }) => {
    return runQuery(entry.query)
  }
}

module.exports = {
  config: null,
  init: function(config) {
    this.config = { ...config }
    const initConfig = { ...config }
    connection = mysql.createPool(initConfig)
  },
  close: () => {
    connection.end()
  },
  handleStepIndexError: function(err) {
    if (err.code === 'ER_NO_SUCH_TABLE' && err.errno === 1146) {
      const entry = {
        action: 'createObject',
        name: 'back_steps',
        properties: [
          {
            name: 'step',
            type: 'number'
          },
          {
            name: 'createdTime',
            type: 'DATETIME',
            default: 'CURRENT_TIMESTAMP'
          }
        ]
      }
      return this.applyStepEntry({ entry })
    }
  },
  logStepComplete: async function({ stepIndex }) {
    const entry = {
      query: `INSERT INTO back_steps (step) VALUES (${stepIndex})`
    }
    return actions['query']({ entry }).catch(async err => {
      console.log(err)
      await this.handleStepIndexError(err)
      // await this.logStepComplete(stepIndex)
    })
  },
  currentStep: async function() {
    const entry = {
      query: 'SELECT * FROM back_steps ORDER BY createdTime DESC'
    }
    const result = await actions['query']({ entry }).catch(async err => {
      await this.handleStepError(err)
    })
    const step = result && result.length && result[0].step
    if (step !== false) {
      return step
    }
    return -1
  },
  applyStepEntry: function({ entry }) {
    return actions[entry.action]({ entry })
  },
  handleStepError: async function(err) {
    console.log(err)
    if (err.code === 'ER_BAD_DB_ERROR' && err.errno === 1049) {
      const entry = {
        action: 'createSpace',
        name: this.config.database
      }
      const config = this.config
      delete config.database
      connection.end()
      connection = mysql.createConnection(config)
      await this.applyStepEntry({ entry })
      connection.end()
      this.init()
    }
  },
  get: async ({ objectName, relation, idName, id = null, filters }) => {
    let whereArr = []
    let whereStr = ''
    let table = objectName
    if (relation) {
      table = relation
      const relationId = `${objectName.replace(/es$|s$/, '')}Id`
      whereArr.push(`HEX(${relationId}) = '${id}'`)
      // TODO: whereArr.push(`${relationId} = ${mysql.escape(id)}`)
    } else if (id !== null && idName.match(/Id$|^id$/)) {
      whereArr.push(`HEX(${idName}) = '${id}'`)
    } else if (id !== null) {
      whereArr.push(`${idName} = '${id}'`)
    }
    if (filters) {
      Object.keys(filters).forEach(name => {
        if (name.match(/Id$|^id$/)) {
          whereArr.push(`HEX(${name}) = ${mysql.escape(filters[name])}`)
        } else {
          whereArr.push(`${name} = ${mysql.escape(filters[name])}`)
        }
      })
    }
    if (whereArr.length) {
      whereStr = ` WHERE ${whereArr.join(' AND ')}`
    }
    const result = await new Promise((res, rej) => {
      connection.query(
        `SELECT * FROM ${table}${whereStr}`,
        (error, results) => {
          if (error) {
            rej(error)
            return
          }
          results.forEach(objectData => {
            Object.keys(objectData).forEach(name => {
              if (
                typeof objectData[name] === 'string' &&
                (objectData[name][0] === '[' || objectData[name][0] === '{')
              ) {
                objectData[name] = JSON.parse(objectData[name])
              } else if (
                objectData[name] &&
                typeof objectData[name] === 'object'
              ) {
                objectData[name] = objectData[name].toString('hex')
              }
            })
          })
          if (!relation && id && results.length) {
            res(results[0])
          } else {
            res(results)
          }
        }
      )
    })
    return result
  },
  add: async ({ objectName, objectData }) => {
    if (Array.isArray(objectData)) {
      const properties = [[Object.keys(objectData[0])], []]
      objectData.forEach((object, i) => {
        properties[1][i] = []
        Object.keys(object).forEach(name => {
          if (typeof object[name] === 'object' && !object[name].toSqlString) {
            properties[1][i].push(JSON.stringify(object[name]))
          } else {
            properties[1][i].push(object[name])
          }
        })
      })
      const results = new Promise((res, rej) => {
        connection.query(
          `INSERT INTO ${objectName} (??) VALUES ?`,
          properties,
          error => {
            if (error) {
              rej(error)
              return
            }
            res(objectData.map(object => ({ id: object.id.value })))
          }
        )
      })
      return results
    } else {
      Object.keys(objectData).forEach(name => {
        if (
          typeof objectData[name] === 'object' &&
          !objectData[name].toSqlString
        ) {
          objectData[name] = JSON.stringify(objectData[name])
        }
      })
      const results = new Promise((res, rej) => {
        connection.query(
          `INSERT INTO ${objectName} SET ?`,
          objectData,
          error => {
            if (error) {
              rej(error)
              return
            }
            res([{ id: objectData.id.value }])
          }
        )
      })
      return results
    }
  },
  update: async function({ objectName, id = null, idName, objectData }) {
    if (Array.isArray(objectData)) {
      const results = []
      for (let item of objectData) {
        const result = await this.update({
          objectName,
          id,
          idName,
          objectData: item
        })
        results.push(result)
      }
      return results
    }

    let where = ''
    if (id !== null && idName.match(/Id$|^id$/)) {
      where = `WHERE HEX(${idName}) = ?`
    } else if (id !== null) {
      where = `WHERE ${idName} = ?`
    } else {
      id = objectData.id
      where = `WHERE HEX(${idName}) = ?`
    }
    delete objectData.id
    Object.keys(objectData).forEach(name => {
      if (
        typeof objectData[name] === 'object' &&
        !objectData[name].toSqlString
      ) {
        objectData[name] = JSON.stringify(objectData[name])
      }
    })
    const result = await new Promise((res, rej) => {
      connection.query(
        `UPDATE ${objectName} SET ? ${where}`,
        [objectData, id],
        (error, results) => {
          if (error) {
            rej(error)
            return
          }
          res(results)
        }
      )
    })
    return result
  },
  delete: async () => {
    // Not supported yet
    return false
  }
}
